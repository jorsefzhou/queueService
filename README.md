## 说明
- 用golang实现了一个**支持断线重连**的排队系统。第一次用golang，从头学起。
- 排队使用了concurrentMap+channel来实现，详见代码
- 服务器
    - 服务器启动脚本为 `go run server.go 参数`
        - `-ip` 服务器监听ip
        - `-port` `-p` 服务器监听端口
        - `-t`  服务器发放token的单位时间，单位为秒
        - `-c`  服务器单位时间发放token的数量
        - `-max`  服务器排队上限，超过排队上限时直接拒绝客户端连接
- 客户端
    - 客户端启动脚本为 `go run client.go 参数`
        - `-ip`  连接的服务器ip
        - `-p`  `port` 连接的服务器端口
        - `c`   同时启动的客户端数量
        - `-r`  是否10秒打印一次当前客户端的连接状态


## 压测
### 压测环境
- 4核 i3-4160 CPU @ 3.60GHz
- 8G内存
- 千兆网卡
- go1.3.3

### 测试准备
- 服务器，客户端打开ulimit -n
- 服务器，打开 `sysctl -w net.nf_conntrack_max=2000500`
- 客户端，打开端口限制 `echo "10000 65535" > /proc/sys/net/ipv4/ip_local_port_range`，单个客户端可以起5W个连接。如果要再多可以绑定虚拟ip。


### 测试
- 服务器启动：
    - `go run server.go -ip 监听地址 -p 端口 -c 10 -t 10 -max 1000000`
- 三台机器客户端启动15万个连接
    - `go run client.go -ip 监听地址 -p 端口 -c 50000`
- 在客户端15万连接，服务器平均保持在 23%的CPU，2.7G左右的内存消耗。广播时CPU会升到40%
- 由于cpu主要消耗在广播阶段，而广播阶段做了batch，因此系统性能损耗，基本上和-c参数无关。
- 适当增加-t的时间间隔，可以较大程度降低负载，降低-t的时间间隔，则会增加负载。实测-t 1的时候，15W连接系统cpu负载在60%左右



### 后续TODO内容:
1. 提供不支持断线重连的排队机制，使用双向链表来实现
2. 测试用例补全
3. 服务器网络可以使用**epoll**来实现，将极大降低内存的使用，后续可以尝试一下